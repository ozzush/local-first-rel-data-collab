\documentclass[a4paper, 11pt, oneside]{article}

% To use this template, you have to have a halfway complete LaTeX
% installation and you have to run pdflatex, followed by bibtex,
% following by one-two more pdflatex runs.
%
% Note thad usimg a spel chequer (e.g. ispell, aspell) is generolz
% a very guud ideo.

\usepackage[utf8]{inputenc}
\usepackage[a4paper, top=3cm, bottom=3cm, left=3cm, right=3cm]{geometry}
\renewcommand{\familydefault}{\sfdefault}
\usepackage{helvet}
\usepackage{listings}
\usepackage[english]{babel} %% typographie française
\usepackage[style=numeric, language=english]{biblatex}
\usepackage{parskip} %% blank lines between paragraphs, no indent
\usepackage[margin=1cm]{caption}%% give long captions a margin
\usepackage{booktabs} %% typesetting nice tables
% \usepackage[cache=false]{minted}%% typesetting code nicely
\usepackage[pdftex]{graphicx} %% include graphics, preferrably pdf
\usepackage[pdftex]{hyperref} %% many PDF options can be set here
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{csquotes}
\pdfadjustspacing=1 %% force LaTeX-like character spacing

\newcommand{\mylastname}{Sirotkina}
\newcommand{\myfirstname}{Veronika}
\newcommand{\mynumber}{30006541}
\newcommand{\myname}{\myfirstname{} \mylastname{}}
\newcommand{\mytitle}{Local-first Collaboration on Relational Data}
\newcommand{\mysupervisor}{??? Anton Podkopaev}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\hypersetup{
pdfauthor={\myname},
pdftitle={\mytitle},
pdfkeywords={},
colorlinks={true},
linkcolor={blue}
}

\addbibresource{refs.bib}

\begin{document}
\pagenumbering{roman}

\thispagestyle{empty}

\begin{flushright}
\includegraphics[scale=0.8]{img/bsc-logo.png}
\end{flushright}
\vspace*{40mm}
\begin{center}
\huge \textbf{\mytitle}
\end{center}
\vspace*{4mm}
\begin{center}
\Large by
\end{center}
\vspace*{4mm}
\begin{center}
\LARGE \textbf{\myname}
\end{center}
\vspace*{20mm}
\begin{center}
\Large Bachelor Thesis in Computer Science
\end{center}
\vfill
\begin{flushleft}
\large Submission: \today \hfill Supervisor: \mysupervisor \\ \rule{\textwidth}{1pt}
\end{flushleft}
\begin{center}
Constructor University $|$ School of Computer Science and Engineering
\end{center}

\newpage
\thispagestyle{empty}

\begin{center}
\Large \textbf{Statutory Declaration}
\vspace*{8mm}
\end{center}

\begin{center}
\begin{tabular}{|l|p{85mm}|}
\hline
Family Name, Given/First Name & \mylastname, \myfirstname \\
Matriculation number          & \mynumber                 \\
Kind of thesis submitted      & Bachelor Thesis           \\
\hline
\end{tabular}
\vspace*{8mm}
\end{center}

\subsection*{English: Declaration of Authorship}

I hereby declare that the thesis submitted was created and written solely by
myself without any external support. Any sources, direct or indirect, are marked
as such. I am aware of the fact that the contents of the thesis in digital
form may be revised with regard to usage of unauthorized aid as well as
whether the whole or parts of it may be identified as plagiarism. I do agree my
work to be entered into a database for it to be compared with existing sources,
where it will remain in order to enable further comparisons with future theses.
This does not grant any rights of reproduction and usage, however.

This document was neither presented to any other examination board nor has it
been published.

\subsection*{German: Erklärung der Autorenschaft (Urheberschaft)}

Ich erkläre hiermit, dass die vorliegende Arbeit ohne fremde Hilfe
ausschließlich von mir erstellt und geschrieben worden ist. Jedwede verwendeten
Quellen, direkter oder indirekter Art, sind als solche kenntlich gemacht worden.
Mir ist die Tatsache bewusst, dass der Inhalt der Thesis in digitaler Form geprüft
werden kann im Hinblick darauf, ob es sich ganz oder in Teilen um ein Plagiat
handelt. Ich bin damit einverstanden, dass meine Arbeit in einer Datenbank
eingegeben werden kann, um mit bereits bestehenden Quellen verglichen zu werden
und dort auch verbleibt, um mit zukünftigen Arbeiten verglichen werden zu
können. Dies berechtigt jedoch nicht zur Verwendung oder Vervielfältigung.

Diese Arbeit wurde noch keiner anderen Prüfungsbehörde vorgelegt noch wurde sie
bisher veröffentlicht.

\vspace{20mm}

\dotfill\\ Date, Signature

\newpage

\section*{Abstract}
TODO

\newpage
\tableofcontents

\clearpage
\pagenumbering{arabic}

\section{Introduction}

With internet becoming more accessible and cloud-based software gaining momentum, more apps started to heavily depend on the presence of internet connection to work properly. This is especially true for apps that need to synchronize clients' data across multiple devices or apps that allow for real-time collaboration between clients.

The most obvious and maybe the easiest way to enable synchronization across devices is naturally to store an authoritative copy of the data in the cloud and provide a centralized server to manage changes coming from the clients. Real-time collaboration can be achieved by implementing operational transformation algorithms \cite{operational}.

This approach is, of course, viable and is widely used in practice, but it has a big downside. Without internet connection access to the data is either lost completely or it is only available in a read-only mode. The access can also be lost if the provider company's servers are down, or if the company stops supporting the product, or if the company finds the contents of the document inappropriate \cite{googleblock}. 

Local-first software \cite{localfirst} is a new approach to designing collaborative software. In the context of this paper the most notable feature of local-first software is that it allows clients to edit shared documents even when they are offline. The changes can be integrated with the upstream version once the connectivity is reestablished.

GanttProject \cite{ganttsite,ganttrepo} is an open-source tool for building Gantt diagrams. It's originally local-only, but at the current time it also provides a cloud storage \cite{ganttcloudsite}. A work-in-progress module called Colloboque will enable real-time colloboration in GanttProject.

The goal of this project is to enable local-first real-time collaboration in GanttProject by further developing Colloboque.

\section{Background}
TODO
\subsection{Operational Transformation}

Operational Transformation \cite{ot} or OT is a technology for managing concurrent updates, particularly in collaboration software. OT algorithms assume that there are multiple clients. All clients have a replica of the same document and they can modify the document with a predetermined set of operations independently from each other.

When a client recieves an update from another client, he doesn't apply the recieved operation immediately. He compares the incoming change against other observed concurrent changes, transforms the operation and then applies it. The transformation algorithm must ensure that the states of all clients converge.

\subsubsection{OT for plain text}
TODO: PICTURE

In this section I will present an example of how OT can be used for managing concurrent insertions in plain text documents.

There are two clients, Alice and Bob, and each of them has a copy of a document. The document contains a single sentence: "Hello World". The only defined operation is an insertion of a single character at a specified position: \verb|insert(char, pos)|.


Alice inserts a comma after "Hello" with \verb|insert(',', 5)| and gets "Hello, World", while Bob inserts an exclamation mark after "World" with \verb|insert('!', 11)| and gets "Hello World!". After that they exchange the performed operations.

If Alice and Bob both apply each other's changes as is, Alice will get "Hello, Worl!d", and Bob will get "Hello, World!" - the two documents now diverge. Instead, when Alice gets \verb|insert('!', 11)| she compares it with the operation she performed concurrently \verb|insert(',', 5)|, sees that the indexing has shifted and transforms \verb|insert('!', 11)| into \verb|insert('!', 12)|. After applying this transformed operation she will get "Hello, World!". 

Bob performs similar actions to learn that he doesn't need to transform Alice's operation, applies it as is and also gets "Hello, World!".

\subsubsection{Google Wave}

Google Wave \cite{wavewiki,waveyt} was a communication platform developed by Google using Operational Transformation approach. It was launched in September 2009. Google Wave combined elements of email, instant messaging, wikis, and social networks into a single platform.

Google Wave had features such as real-time collaboration, allowing users to work together on documents known as "waves" by typing messages, inserting images, and adding other content. It supported the embedding of media objects like videos, maps, and polls directly into waves.

Despite its innovative features, Google Wave failed to gain popularity. Google discontinued Google Wave in August 2010 due to low user adoption, but its technology and concepts influenced subsequent Google products like Google Docs and Google Drive.

\subsection{Local-first Software}
Local-first software was first formalized in 2019. The original paper \cite{localfirst} suggests 7 principles of local-first software. Here I will list 4 which I find the most relevant.
\begin{itemize}
    \item \textbf{Synchronization across devices} \\
    Imagine a client who uses a document editor on multiple devices. Synchronization involves tracking changes made by the client on one device and ensuring these changes are reflected across all other devices used by the client. In the end data on all devices must reach the same state. This is a very convenient feature that lets clients acces their work from any device.

    \item \textbf{The network is optional} \\
    Nowadays it is normal for many apps to lose most of their functionality if internet connection is unstable. TODO: EXAMPLES. For local-first software it is important that it should retain its core functionality even when the device is offline. The client is still able to view and edit documents as he pleases, and the changes made while being offline are integrated with other replicas when the device connects to the network again.

    \item \textbf{Seamless collaboration} \\
    Real-time collaboration is a very attractive feature that lets multiplea people work on a single document simultaneously. Some notable examples of web-apps that allow for real-time collaboration are Google Docs, Google Sheets, Figma, etc. Usually such apps don't allow to edit documents offline with some Google products like Google Docs being an exception. For local-first software the aim is to provide collaboration functionality on par with cloud-based apps like Figma while retaining optionality of the network.

    \item \textbf{Ultimate ownership and control} \\
    As a popular saying goes, there is no cloud - it's just someone else's computer. When user data is stored in the cloud, the ultimate ownership of the data belongs to the corporation that provides the software. The user might lose acces to their data because of technical problems, or, what's more concerning, the company might bar the user from accessing their data on a whim. For example, by introducing a paid subscription or banning the user because their data presumably violates the service's policies \cite{googleblock}. With local-first software, the data physically belongs to the user and the service provider can't take the user's access.
\end{itemize}

\subsection{CRDT}
CRDT stands for Conflict-Free Replicated Data Type \cite{crdt}. CRDT object has an identifier, content, an initial state, and a set of operations. Any two objects with the same identifiers are called replicas of each other. An abstract state of a CRDT object is represented by the collective result of all read-only operations. CRDT guarantees that all well-formed update operations are commutative and idempotent with respect to the abstract state of an object. Because of these properties, replicas can make updates independently, without communicating wiht other replicas. As long as all updates are eventually communicated, all replicas are guaranteed to end up with the same abstract state.

CRDT types can be further categorized into two groups:  State-based CRDTs and Operation-based CRDTs

\subsubsection{State-based CRDT}
First, let's define Causal History for state-based CRDT objects.

\begin{definition}[Causal History — state-based]
    For any replica $x_i$ of $x$:
\begin{itemize}
    \item Initially, $C(x_i) = \emptyset$.
    \item After executing update operation $f$, $C(f(x_i)) = C(x_i) \cup \{f\}$.
    \item After executing merge against states $x_i, x_j$, $C(merge(x_i, x_j)) = C(x_i) \cup C(x_j)$.
\end{itemize}
\end{definition}
TODO

\subsubsection{Operation-based CRDT}
TODO

\subsubsection{Automerge}
Automerge \cite{automerge} is a library that provides a JSON-like CRDT for JavaScript. It was designed specifically for implementing local-first software. Automerge documents support all JSON primitive data types, as well as Map, List, Text, and Counter. 

TODO: AUTOMERGE USAGE EXAMPLE

Automerge documents support both merging full documents and applying individual changes. To define rules for merging documents, it's enough to define rules for merging Maps, Lists, Text and Counters. Full explanation of the merging rules in Automerge can be found in Automerge documentation \cite{automergerules}.

TODO: CONFLICT OBJECT

\subsubsection{Crecto}
\subsection{Leader-Based Log Replication}
TODO
\subsection{Time Warp}
TODO

\section{Approaches}
TODO
\subsection{CRDT approach}
TODO
\subsection{Time Warp approach}
TODO
\subsection{Transaction replay approach}
TODO: POLISH CODE LISTINGS

The Colloboque server stores transaction history and the state of the project after each transaction. When a client loses connection to the server, it keeps commiting transactions locally. When connection is re-established, the set of changes applied by the client is sent to the server. The server then takes the state of the project that the out-of-sync client based its changes on and uses it to start two transactions. The first transaction contains all the changes that the client applied locally, while the second transaction contains all the changes processed by the server while the client was disconnected. 

\subsubsection{Postgres transaction isolation levels} 
In the described approach transactions have to make use of isolation level REPEATABLE READ, which is stronger than the default transaction isolation level.

The default mode for transactions in Postgres is READ COMMITTED \cite{tisolevel}. It means that a transaction is allowed to read changes that where committed by other transactions after the current transaction has started. 

\begin{lstlisting}[language=SQL]
BEGIN;
SELECT * FROM data; -- 0 rows
-- another transaction commits inserting a row
SELECT * FROM data; -- 1 rows
COMMIT;
\end{lstlisting}

When using REPEATABLE READ transaction mode, the changes from newly committed transactions are not visible, but if the current transaction makes a conflicting update, it will lead to a serialization error.

\begin{lstlisting}[language=SQL]
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SELECT * FROM data; -- 1 rows
-- another transaction commits deleting a row
SELECT * FROM data; -- 1 rows
UPDATE data SET col = 1;
-- ERROR:  could not serialize access due to concurrent delete
\end{lstlisting}

With this approach the Postgres database can reliably identify whether the changes that the client made offline produce confilcts. If there are conflicts, the server discards the changes. The client will then have to sync with the server. An out-of-sync version of the document can be saved as a copy so that the client can compare the two versions manually.

\section{Implementation}

\newpage
\printbibliography
\clearpage
\end{document}