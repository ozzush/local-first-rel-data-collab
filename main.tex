\documentclass[a4paper, 11pt, oneside]{article}

% To use this template, you have to have a halfway complete LaTeX
% installation and you have to run pdflatex, followed by bibtex,
% following by one-two more pdflatex runs.
%
% Note thad usimg a spel chequer (e.g. ispell, aspell) is generolz
% a very guud ideo.

\usepackage[utf8]{inputenc}
\usepackage[a4paper, top=3cm, bottom=3cm, left=3cm, right=3cm]{geometry}
\renewcommand{\familydefault}{\sfdefault}
\usepackage{helvet}
\usepackage{listings}
\usepackage[english]{babel} %% typographie française
\usepackage[style=numeric, language=english]{biblatex}
\usepackage{parskip} %% blank lines between paragraphs, no indent
\usepackage[margin=1cm]{caption}%% give long captions a margin
\usepackage{booktabs} %% typesetting nice tables
% \usepackage[cache=false]{minted}%% typesetting code nicely
\usepackage[pdftex]{graphicx} %% include graphics, preferrably pdf
\usepackage[pdftex]{hyperref} %% many PDF options can be set here
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{csquotes}
\pdfadjustspacing=1 %% force LaTeX-like character spacing

\newcommand{\mylastname}{Sirotkina}
\newcommand{\myfirstname}{Veronika}
\newcommand{\mynumber}{30006541}
\newcommand{\myname}{\myfirstname{} \mylastname{}}
\newcommand{\mytitle}{Local-first Collaboration on Relational Data}
\newcommand{\mysupervisor}{??? Anton Podkopaev}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\hypersetup{
pdfauthor={\myname},
pdftitle={\mytitle},
pdfkeywords={},
colorlinks={true},
linkcolor={blue}
}

\addbibresource{refs.bib}

\begin{document}
\pagenumbering{roman}

\thispagestyle{empty}

\begin{flushright}
\includegraphics[scale=0.8]{img/bsc-logo.png}
\end{flushright}
\vspace*{40mm}
\begin{center}
\huge \textbf{\mytitle}
\end{center}
\vspace*{4mm}
\begin{center}
\Large by
\end{center}
\vspace*{4mm}
\begin{center}
\LARGE \textbf{\myname}
\end{center}
\vspace*{20mm}
\begin{center}
\Large Bachelor Thesis in Computer Science
\end{center}
\vfill
\begin{flushleft}
\large Submission: \today \hfill Supervisor: \mysupervisor \\ \rule{\textwidth}{1pt}
\end{flushleft}
\begin{center}
Constructor University $|$ School of Computer Science and Engineering
\end{center}

\newpage
\thispagestyle{empty}

\begin{center}
\Large \textbf{Statutory Declaration}
\vspace*{8mm}
\end{center}

\begin{center}
\begin{tabular}{|l|p{85mm}|}
\hline
Family Name, Given/First Name & \mylastname, \myfirstname \\
Matriculation number          & \mynumber                 \\
Kind of thesis submitted      & Bachelor Thesis           \\
\hline
\end{tabular}
\vspace*{8mm}
\end{center}

\subsection*{English: Declaration of Authorship}

I hereby declare that the thesis submitted was created and written solely by
myself without any external support. Any sources, direct or indirect, are marked
as such. I am aware of the fact that the contents of the thesis in digital
form may be revised with regard to usage of unauthorized aid as well as
whether the whole or parts of it may be identified as plagiarism. I do agree my
work to be entered into a database for it to be compared with existing sources,
where it will remain in order to enable further comparisons with future theses.
This does not grant any rights of reproduction and usage, however.

This document was neither presented to any other examination board nor has it
been published.

\subsection*{German: Erklärung der Autorenschaft (Urheberschaft)}

Ich erkläre hiermit, dass die vorliegende Arbeit ohne fremde Hilfe
ausschließlich von mir erstellt und geschrieben worden ist. Jedwede verwendeten
Quellen, direkter oder indirekter Art, sind als solche kenntlich gemacht worden.
Mir ist die Tatsache bewusst, dass der Inhalt der Thesis in digitaler Form geprüft
werden kann im Hinblick darauf, ob es sich ganz oder in Teilen um ein Plagiat
handelt. Ich bin damit einverstanden, dass meine Arbeit in einer Datenbank
eingegeben werden kann, um mit bereits bestehenden Quellen verglichen zu werden
und dort auch verbleibt, um mit zukünftigen Arbeiten verglichen werden zu
können. Dies berechtigt jedoch nicht zur Verwendung oder Vervielfältigung.

Diese Arbeit wurde noch keiner anderen Prüfungsbehörde vorgelegt noch wurde sie
bisher veröffentlicht.

\vspace{20mm}

\dotfill\\ Date, Signature

\newpage

\section*{Abstract}
TODO

\newpage
\tableofcontents

\clearpage
\pagenumbering{arabic}

\section{Introduction}

With internet becoming more accessible and cloud-based software gaining momentum, more apps started to heavily depend on the presence of internet connection to work properly. This is especially true for apps that need to synchronize clients' data across multiple devices or apps that allow for real-time collaboration between clients.

The most obvious and maybe the easiest way to enable synchronization across devices is naturally to store an authoritative copy of the data in the cloud and provide a centralized server to manage changes coming from the clients. Real-time collaboration can be achieved by implementing operational transformation algorithms \cite{ot}.

This approach is, of course, viable and is widely used in practice, but it has a big downside. Without internet connection access to the data is either lost completely or it is only available in a read-only mode. The access can also be lost if the provider company's servers are down, or if the company stops supporting the product, or if the company finds the contents of the document inappropriate \cite{googleblock}. 

Local-first software \cite{localfirst} is a new approach to designing collaborative software. In the context of this paper the most notable feature of local-first software is that it allows clients to edit shared documents even when they are offline. The changes can be integrated with the upstream version once the connectivity is reestablished.

GanttProject \cite{ganttsite,ganttrepo} is an open-source tool for building Gantt diagrams. It's originally local-only, but at the current time it also provides a cloud storage \cite{ganttcloudsite}. A work-in-progress module called Colloboque will enable real-time colloboration in GanttProject.

The goal of this project is to enable local-first real-time collaboration in GanttProject by further developing Colloboque.

\section{Background}
TODO
\subsection{Operational Transformation}

Operational Transformation \cite{ot} or OT is a technology for managing concurrent updates, particularly in collaboration software. OT algorithms assume that there are multiple clients. All clients have a replica of the same document and they can modify the document with a predetermined set of operations independently from each other.

When a client recieves an update from another client, he doesn't apply the recieved operation immediately. He compares the incoming change against other observed concurrent changes, transforms the operation and then applies it. The transformation algorithm must ensure that the states of all clients converge.

\subsubsection{OT for plain text}
TODO: PICTURE

In this section I will present an example of how OT can be used for managing concurrent insertions in plain text documents.

There are two clients, Alice and Bob, and each of them has a copy of a document. The document contains a single sentence: "Hello World". The only defined operation is an insertion of a single character at a specified position: \verb|insert(char, pos)|.


Alice inserts a comma after "Hello" with \verb|insert(',', 5)| and gets "Hello, World", while Bob inserts an exclamation mark after "World" with \verb|insert('!', 11)| and gets "Hello World!". After that they exchange the performed operations.

If Alice and Bob both apply each other's changes as is, Alice will get "Hello, Worl!d", and Bob will get "Hello, World!" - the two documents now diverge. Instead, when Alice gets \verb|insert('!', 11)| she compares it with the operation she performed concurrently \verb|insert(',', 5)|, sees that the indexing has shifted and transforms \verb|insert('!', 11)| into \verb|insert('!', 12)|. After applying this transformed operation she will get "Hello, World!". 

Bob performs similar actions to learn that he doesn't need to transform Alice's operation, applies it as is and also gets "Hello, World!".

\subsubsection{Google Wave}

Google Wave \cite{wavewiki,waveyt} was a communication platform developed by Google using Operational Transformation approach. It was launched in September 2009. Google Wave combined elements of email, instant messaging, wikis, and social networks into a single platform.

Google Wave had features such as real-time collaboration, allowing users to work together on documents known as "waves" by typing messages, inserting images, and adding other content. It supported the embedding of media objects like videos, maps, and polls directly into waves.

Despite its innovative features, Google Wave failed to gain popularity. Google discontinued Google Wave in August 2010 due to low user adoption, but its technology and concepts influenced subsequent Google products like Google Docs and Google Drive.

\subsection{Local-first Software}
Local-first software was first formalized in 2019. The original paper \cite{localfirst} suggests 7 principles of local-first software. Here I will list 4 which I find the most relevant.
\begin{itemize}
    \item \textbf{Synchronization across devices} \\
    Imagine a client who uses a document editor on multiple devices. Synchronization involves tracking changes made by the client on one device and ensuring these changes are reflected across all other devices used by the client. In the end data on all devices must reach the same state. This is a very convenient feature that lets clients acces their work from any device.

    \item \textbf{The network is optional} \\
    Nowadays it is normal for many apps to lose most of their functionality if internet connection is unstable. TODO: EXAMPLES. For local-first software it is important that it should retain its core functionality even when the device is offline. The client is still able to view and edit documents as he pleases, and the changes made while being offline are integrated with other replicas when the device connects to the network again.

    \item \textbf{Seamless collaboration} \\
    Real-time collaboration is a very attractive feature that lets multiplea people work on a single document simultaneously. Some notable examples of web-apps that allow for real-time collaboration are Google Docs, Google Sheets, Figma, etc. Usually such apps don't allow to edit documents offline with some Google products like Google Docs being an exception. For local-first software the aim is to provide collaboration functionality on par with cloud-based apps like Figma while retaining optionality of the network.

    \item \textbf{Ultimate ownership and control} \\
    As a popular saying goes, there is no cloud - it's just someone else's computer. When user data is stored in the cloud, the ultimate ownership of the data belongs to the corporation that provides the software. The user might lose acces to their data because of technical problems, or, what's more concerning, the company might bar the user from accessing their data on a whim. For example, by introducing a paid subscription or banning the user because their data presumably violates the service's policies \cite{googleblock}. With local-first software, the data physically belongs to the user and the service provider can't take the user's access.
\end{itemize}

\subsection{CRDT}
CRDT stands for Conflict-Free Replicated Data Type \cite{crdt}. It's a type of data structure designed for distributed systems. Objects of CRDTs can be replicated across multiple nodes, and each node can independently update the object. When information about the updates or, depending on the flavour of a particular CRDT specification, the state of each node is shared, CRDTs guarantee that all replicas will eventually reach the same state.

CRDT object has an identifier, physical content and an initial state. Any two objects with the same identifiers are called replicas of each other. CRDT specification defines a set of update operations, as well as read-only queries.

A CRDT can implement any logical type like Counter, Set, List, etc. The state of a CRDT's logical type is represented by its abstract state. For example, a Counter CRDT can be implemented as a tuple of values, where each replica can only change its designated value. The abstract state of such CRDT is the sum of all values in a tuple. 

TODO: CLARIFY COUNTER CRDT?

CRDT guarantees that all well-formed update operations are commutative and idempotent with respect to the abstract state of an object. Because of these properties, replicas can make updates independently, without communicating with other replicas. As long as all updates are eventually communicated, all replicas are guaranteed to end up with the same abstract state.

CRDT types can be further categorized into two groups:  state-based CRDTs and operation-based CRDTs. It is worth noting that state-based CRDTs can always be emulated by operation-based CRDTs and operation-based CRDTs can always be emulated by state-based CRDTs. But for some structures it's simpler to think in terms of state-based CRDT, while some feel more natural as an operation-based CRDT.

% For example, consider two implementations for a CRDT counter

\subsubsection{State-based CRDT}
For state-based CRDT one has to specify a merge function, which will merge together states of two different replicas. Requirements for the merge function can be formulated in terms of causal history.

\begin{definition}[Causal History — state-based]
    For any replica $x_i$ of $x$:
\begin{itemize}
    \item Initially, $C(x_i) = \emptyset$.
    \item After executing update operation $f$, $C(f(x_i)) = C(x_i) \cup \{f\}$.
    \item After executing merge against states $x_i, x_j$, $C(merge(x_i, x_j)) = C(x_i) \cup C(x_j)$.
\end{itemize}
\end{definition}

Here is an example implementation of a state-based Counter CRDT

\begin{lstlisting}[language=Java]
Counter {
    // initial state
    val counter = (0, 0, 0)

    // identifier from {0, 1, 2}
    val id

    // update operation
    fun increment() {
        counter[id] += 1
    }

    // query
    fun value() = sum(counter)

    // merge function
    fun merge(c1, c2) {
        merged = (0, 0, 0)
        for (i in 0..2) {
            merged[i] = max(c1[i], c2[i])
        }
        return merged
    }
}
\end{lstlisting}

\subsubsection{Operation-based CRDT}
TODO

\begin{definition}[Causal History — operation-based]
    For any replica $x_i$ of $x$:
\begin{itemize}
    \item Initially, $C(x_i) = \emptyset$.
    \item After executing update operation $f$, $C(f(x_i)) = C(x_i) \cup \{f\}$.
\end{itemize}
\end{definition}

\subsubsection{Automerge}
Automerge \cite{automerge} is a library that provides a JSON-like CRDT for JavaScript. It was designed specifically for implementing local-first software. Automerge documents support all JSON primitive data types, as well as Map, List, Text, and Counter. 

TODO: AUTOMERGE USAGE EXAMPLE

Automerge documents support both merging full documents and applying individual changes. To define rules for merging documents, it's enough to define rules for merging Maps, Lists, Text and Counters. Full explanation of the merging rules in Automerge can be found in Automerge documentation \cite{automergerules}.

Some conflicts can't be automaticaly resolved, for example if two replicas concurrently set the same key. In events like this Automerge produces a Conflict object, which contains updates from both replicas. They can be used to allow the user to pick the value manually, but this is not mandatory. Conflict objects can be completely ignored, in which case a single value is picked automaticaly from the list of available options presented by the Conflict object. The library guarantees that if two replicas encounter the same Conflict, it will be resolved in a consistent way, ensuring that the two replicas still converge.

The core of Automerge is written in Rust. Consider the following example using Automerge's Rust API demonstrating Conflict objects.

TODO: FIX LISTING
\begin{lstlisting}[language=C++]
use automerge::ReadDoc;
use automerge::transaction::Transactable;

fn main() {
    let mut first_doc = automerge::Automerge::new();
    let mut second_doc = first_doc.fork();
    first_doc.transact::<_, _, automerge::AutomergeError>(|doc| {
        Ok(doc.put(automerge::ROOT, "key", "first value").unwrap())
    }).unwrap();
    second_doc.transact::<_, _, automerge::AutomergeError>(|doc| {
        Ok(doc.put(automerge::ROOT, "key", "second value").unwrap())
    }).unwrap();
    first_doc.merge(&mut second_doc).unwrap();
    second_doc.merge(&mut first_doc).unwrap();
    let conflict1: Vec<_> = first_doc.get_all(automerge::ROOT, "key").unwrap();
    let value1 = first_doc.get(automerge::ROOT, "key").unwrap().unwrap().0;
    let conflict2: Vec<_> = second_doc.get_all(automerge::ROOT, "key").unwrap();
    let value2 = second_doc.get(automerge::ROOT, "key").unwrap().unwrap().0;

    println!("Conflict in the first document:\n{:?}", conflict1);
    println!("Conflict in the second document:\n{:?}", conflict2);
    println!("First conflict resolves to  {:?}", value1);
    println!("Second conflict resolves to {:?}", value2);

    // Possible output
    // Conflict in the first document:
    // [(Scalar(Str("first value")), Id(1, ActorID("1baddedabae54a6ca7a8aaf03dc2a8a4"), 0)), (Scalar(Str("second value")), Id(1, ActorID("43ca89b2a9854a358c5ea75c26ae735c"), 1))]
    // Conflict in the second document:
    // [(Scalar(Str("first value")), Id(1, ActorID("1baddedabae54a6ca7a8aaf03dc2a8a4"), 1)), (Scalar(Str("second value")), Id(1, ActorID("43ca89b2a9854a358c5ea75c26ae735c"), 0))]
    // First conflict resolves to Scalar(Str("second value"))
    // Second conflict resolves to Scalar(Str("second value"))

}

\end{lstlisting}

\subsubsection{CRDT for Relational Data}

Some work on designing CRDT for relational data have been done before \cite{relcrdt}. In the paper the authors present a two layered architecture. The first layer is the Application Relation layer, or AR layer. The application can interact with the application layer as if it was a normal database. The second layer, called Conflict-free Replicated Relation layer or CRR layer, handles the logic of applying and propagating updates. The CRR layer contains an AR layer schema, augmented with additional data to implement CRDT logic.

Read-only queries can be executed directly on the application layer. Update requests are applied atomicaly to both AR and CRR schemas. Later they are propagated to other replicas.

The CRR layer is responsible for handling conflicts between local updates and concurrent updates propagated by other replicas. To achieve that the CRR layer stores rows in a special Set CRDT called CLSet, and all row attributes are stored in a Last-Writer-Wins register CRDT. Some numeric attributes are represented by Counter CRDT.

CLSet maintains a counter for each object in the set. This number is called the \textit{causal length} of an object. Successful inserts and removals increment causal length, while unsuccessful operations have no effect. For example, removing an object that doesn't belong to the set has no effect, while removing an object that does belong to the set increments the object's causal length. Following this specification, we can conclude that an object belongs to the set if and only if its causal length is odd. When handling conflicting updates, an update with the greatest causal length wins.

Another problem that the CRR layer needs to solve is maintaining integrity constraints. If some constraints are violated when applying a local update the update can be simply rolled back. The main challenge comes from integrity constaint violations happening when merging updates from other replicas. In this case the CRR layer generates a new update that undoes the conflicting update and propagates it to other replicas.

The paper discusses three kinds of integrity constraints violations. 

The first one is uniqueness constraint violation. When two updates conflict because of a uniqueness constraint violation, update with a higher timestamp is reverted. 

The second one is referential integrity constraint violation. It can happen when one replica updates or inserts a row with a foreign key $f$, while another replica deletes the row containing $f$ from the referenced table. In that case the update/insert operation is reverted, because the delete operation might have been the result of undoing an insert after uniqueness constraint violation. In this case undoing the delete operation will lead to encountering a uniqueness constraint violation again.

The third one is numeric constraint violation like lower and upper bounds. Since some numeric attributes behave like counters with additive updates, it's possible to get overflow or underflow after merging concurrent updates. In this case the more recent updates are reverted.

The approach with issuing undo updates is not fit for all cases. For example some operations might have further side-effects, like sending an email or charging a bank account.  An undo operation can't revert the impact made on the external world. Some papers TODO: CITE suggest that this problem could be solved by introducing quotas for certain operation. For example, if the account balance is 1000, and a client has 10 devices, each device can be issued a quota to deduct 100 from the account. If a device wants to deduct more, it must contact other devices to redistribute the quotas. 

% \subsection{Leader-Based Log Replication}
% TODO
% \subsection{Time Warp}
% TODO

\section{Approaches}
In this section I will describe approaches considered during the course of my work.

\subsection{CRDT approach}
The first approach to enabling local-first collaboration in GanttProject is to implement a CRDT for relational data. With a robust relational data CRDT, the task would be very straightforward. Each client can store a replica of a CRDT object and propagate its updates to other clients either through a centralized server or a peer-to-peer connection.

The main challenge comes from implementing a relational data CRDT. The paper referenced in Section 2.3.4 gives a general direction on how such a CRDT can be implemented, but this is still no easy task. It's also unclear whether additional problems could arise due to the limited support of SQL features that the described CRDT provides. For example, it seems impossible to implement an auto-increment attribute. When there is a need to generate unique ids for newly inserted rows the authors of the paper generate random ids instead. There are probably many more such examples, but listing them requires further analysis. 

The described relational data CRDT is implemented in a library for Elixir called Crecto. It can't be used easily since GanttProject is implemented in Java and Kotlin. 

Taking into account the amount of work required to employ this approach and the assiciated concerns it was decided to think of other approaches which would be easier to implement and integrate with the existing codebase.


\subsection{Time Warp approach}
TODO
\subsection{Transaction replay approach}
TODO: POLISH CODE LISTINGS

The Colloboque server stores history committed Postgres database transactions and the state of the project after each transaction. When a client loses connection to the server, he keeps commiting transactions locally. When connection is re-established, the set of changes applied by the client is sent to the server. The server then takes the state of the project that the out-of-sync client based its changes on and uses it to start two transactions. The first transaction contains all the changes that the client applied locally, while the second transaction contains all the changes processed by the server while the client was disconnected. 

\subsubsection{Postgres transaction isolation levels} 
In the described approach transactions have to make use of isolation level REPEATABLE READ, which is stronger than the default transaction isolation level.

The default mode for transactions in Postgres is READ COMMITTED \cite{tisolevel}. It means that a transaction is allowed to read changes that where committed by other transactions after the current transaction has started. 

\begin{lstlisting}[language=SQL]
BEGIN;
SELECT * FROM data; -- 0 rows
-- another transaction commits inserting a row
SELECT * FROM data; -- 1 rows
COMMIT;
\end{lstlisting}

When using REPEATABLE READ transaction mode, the changes from newly committed transactions are not visible, but if the current transaction makes a conflicting update, it will lead to a serialization error.

\begin{lstlisting}[language=SQL]
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SELECT * FROM data; -- 1 rows
-- another transaction commits deleting a row
SELECT * FROM data; -- 1 rows
UPDATE data SET col = 1;
-- ERROR:  could not serialize access due to concurrent delete
\end{lstlisting}

With this approach the Postgres database can reliably identify whether the changes that the client made offline produce confilcts. If there are conflicts, the server discards the changes. The client will then have to sync with the server. An out-of-sync version of the document can be saved as a copy so that the user can compare the two versions manually.

\section{Implementation}

\newpage
\printbibliography
\clearpage
\end{document}